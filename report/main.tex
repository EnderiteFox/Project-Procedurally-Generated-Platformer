\documentclass[10pt]{report}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\usepackage[french]{babel}
\usepackage[a4paper, left=30mm,right=20mm,top=25mm,bottom=25mm]{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage[T1]{fontenc}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\renewcommand\thesection{\arabic{section}}

\begin{document}

\begin{titlepage}
  %\begin{sffamily}
  \begin{center}
    \includegraphics[height=25mm]{gfx/logo-UMLP.png}~\\[3cm]
    
    \textsc{\LARGE UFR Sciences et technique}\\
    \textsc{\Large Université Marie et Louis PASTEUR}\\
    \textsc{\Large \textbf{Projet}}\\
    \textsc{\Large L3 Informatique}\\[2.5cm]
    
    \HRule \\[0.4cm]
    { \huge \bfseries Jeu de plate-formes avec génération procédurale\\[0.4cm] } % C'est le titre donné par jube, j'y suis pour rien
    
    \HRule \\[0.6cm]\renewcommand\thesection{\arabic{section}}
    \textsc{\Large \textbf{Rapport de projet}}\\[1.5cm]
    \begin{minipage}{\textwidth}
      \begin{center}\LARGE
        Kilian \textsc{Jelic} \\
        Laura \textsc{Jacqueson} \\
        Théo \textsc{Pariney} \\
      \end{center}
    \end{minipage}
    \vfill
    % Bottom of the page
    {\large \ avril 2025}
    
  \end{center}
  %\end{sffamily}
\end{titlepage}

\normalsize
\pagenumbering{arabic}
\tableofcontents
\pagebreak
\listoffigures
\pagebreak

\section{Introduction}

Dans le cadre de notre projet semestriel en L3 Informatique à l'Université Marie et Louis Pasteur, nous avons travaillé sur le développement d’un jeu de plate-formes avec génération procédurale en C++. 

Les jeux de plate-formes sont un genre qui repose sur le contrôle d'un personnage avec des mécaniques comme les sauts et les obstacles, l’objectif étant généralement de rejoindre une sortie pour terminer le niveau. L’ajout de la génération procédurale introduit une caractéristique supplémentaire : plutôt que de concevoir chaque niveau à la main, un algorithme est chargé de créer les niveaux du jeu, permettant ainsi une expérience unique à chaque partie.

L'objectif principal de ce projet était de concevoir un jeu de plate-formes dont les niveaux seraient générés de manière procédurale, offrant ainsi une rejouabilité infinie. En parallèle, nous avons dû concevoir un jeu intégrant plusieurs mécaniques de jeu, incluant des déplacements, des sauts, un dash, ainsi qu’un objectif centré sur la récolte d’objets, tout en assurant la gestion des collisions et la physique du jeu.

Dans ce rapport, nous commencerons par une présentation générale du jeu, en exposant les objectifs du joueur et les scènes du jeu. Ensuite, nous détaillerons la conception des blocs et entités qui composent le monde et leur gestion dynamique. Par la suite, nous aborderons la génération procédurale, en expliquant la méthode utilisée ainsi que les détails d'implémentation. Nous discuterons ensuite des contrôles du personnage et des différentes mécaniques de jeu, telles que le saut, le dash, etc. La partie suivante sera consacrée à la physique, notamment la gestion des collisions et des propriétés physiques comme la résistance de l'air. Enfin, nous reviendrons sur l’organisation du travail, la répartition des tâches et les outils utilisés pour mener à bien ce projet. Le rapport se conclura par un bilan du projet et les améliorations possibles.

\pagebreak



\section{Présentation du jeu}
\subsection{Présentation générale}

Ce projet consiste à développer un jeu de plate-forme en 2D intégrant un système de génération procédurale de niveau. L’objectif est d’offrir une expérience où chaque partie est unique : au lieu d’avoir des niveaux prédéfinis, ceux-ci sont générés aléatoirement à chaque nouvelle partie. Contrairement aux jeux de plate-forme classiques où l'on peut apprendre les niveaux par cœur, ici, aucun parcours ne peut être rejoué à l’identique. Cette approche permet non seulement une rejouabilité infinie, mais aussi un défi constant, obligeant le joueur à s’adapter à chaque nouvelle configuration de niveau.

Le joueur incarne un petit robot, dont la mission principale est de récolter un maximum d’écrous avant d’atteindre la sortie du niveau. Ces écrous sont disposés aléatoirement dans l’environnement, incitant le joueur à explorer avant de pouvoir terminer la partie.

Pour évoluer dans le monde, le joueur dispose de plusieurs mécaniques lui permettant de se déplacer librement et d’interagir avec son environnement :
\begin{itemize}
  \item \textbf{déplacement} : le personnage peut se déplacer latéralement, à gauche et à droite, pour parcourir le niveau.
  \item \textbf{saut} : le personnage peut sauter pour franchir des obstacles ou atteindre des plateformes situées en hauteur.
  \item \textbf{double saut} : après un premier saut, lorsqu'il est encore en l’air, le personnage peut effectuer un second saut lui permettant d’atteindre des zones plus élevées.
  \item \textbf{dash} : le personnage dispose également d’un dash, une impulsion rapide dans une direction (gauche ou droite), utile pour traverser de grands espaces vides ou esquiver des obstacles.\\
\end{itemize}

Ces mécaniques offrent une grande liberté de mouvement, permettant aux joueurs d’adopter différentes stratégies. Certains privilégieront une approche prudente, optimisant chaque saut pour éviter la mort, tandis que d’autres tenteront des enchaînements rapides et fluides pour terminer le niveau efficacement.


Comme mentionné précédemment, tous les niveaux sont générés de manière procédurale, cela signifie qu'à chaque lancement de partie c'est un algorithme qui se charge de créer un environnement en plaçant des blocs, plateformes, échelles, écrous, piques et une sortie. Cette méthode permet de générer de manière presque infinie des mondes différents. 

Ces différent niveaux sont composés de salles générées de manière 
contiguës, et les salles sont reliées entre elles par des échelles et des
plateformes, de façon à ce que chaque niveau soit possible, en partant du
début jusqu'à la fin. Des blocs et plateformes de glace et de slime sont 
également générés, et le joueur doit donc faire attention aux changements 
que cela implique sur ses déplacements.
%ajout d'une petite présentation de l'algo de génération


\subsection{Les objectifs du joueur}
\subsubsection{Les écrous}

\subsubsection{La sortie}

\subsection{Les scènes}


\section{Les blocks et entités du monde}
\subsection{La définition dynamique des blocks}
% Fichier XML et récupération dans une classe dédiée
\subsection{Le stockage des blocks}
% Récupération dans le blockmanager utilisé par le monde

\section{La génération procédurale}
% Je sais pas trop comment ça se passe, faudrait le remplir
% Faudra penser à préciser qu'on a commencé par faire un monde "test" avant d'arriver à notre générateur actuel
% Et aussi à donner les étapes/difficultés avant d'en arriver à un truc qui marche correctement

\subsection{Aléatoire et graine de génération}

À des fins de débuggage, la possibilité de pouvoir générer le même monde
plusieurs fois est importante. Pour cela, les niveaux sont générés à l'aide
d'un générateur de nombres pseudo-aléatoire. Ce générateur peut utiliser
un entier codé sur 64 bits, et générera la même séquence de nombres
aléatoires tant que la même graine est utilisée. 

Nous avons donc implémenté
deux moyens de générer les mondes: avec ou sans graine. Si une graine est
donnée au générateur, alors cette graine sera utilisée lors de la création
du niveau. Sinon, une graine aléatoire est choisie, et est affichée dans
la console. Cela permet, en cas de problème, de facilement noter et partager
une graine, permettant de reproduire le problème plus facilement.

\subsection{Étapes de génération}
\subsubsection{Génération des salles}

Les salles sont générées de manière à ce qu'elles soient connectées entre
elles, sans jamais se chevaucher. Pour cela, l'algorithme suivant est 
appliqué:

\begin{itemize}
  \item Générer une salle de départ.
  \item Tant que le nombre de salles voulu n'est pas atteint:
  \begin{itemize}
    \item Choisir aléatoirement la taille de la salle.
    \item Choisir une direction (haut, bas, gauche ou droite)
    \item Créer une nouvelle salle, placée à côté de la salle précédente,
    aléatoirement le long du mur correspondant à la direction choisie.
    \item Si la salle chevauche une autre salle, la regénérer.
    \item Si, au bout d'un certain nombre d'essais, la salle n'a pas réussi
    à se générer, réessayer en changeant la taille de la salle.
    \item Si la salle n'arrive toujours pas à se générer, supprimer la
    salle ainsi que la salle précédente, et regénérer la salle précédente.
  \end{itemize}
\end{itemize}

Certains cas spéciaux se présentent avec cet algorithme:
\begin{itemize}
  \item \textbf{La salle de départ}: La salle de départ, étant la première
  salle, ne peut pas se générer à la suite d'une autre salle. Elle se 
  génère donc simplement aux coordonnées (0, 0)
  \item \textbf{Retour en arrière}: Dans certains cas, une salle peut se 
  retrouver encerclée par d'autre salles. Dans ce cas, aucune salle ne 
  pourra se générer par la suite. Afin d'éviter ces situations, l'
  algorithme décide, si une salle n'arrive pas à se générer, de réessayer 
  d'abord avec une salle de différente taille, car une salle plus petite
  peut éventuellement réussir à se générer. Mais, au bout d'un certain 
  nombre d'essais, l'algorithme décide de retourner en arrière. Dans ce
  cas, la salle précédente est supprimée, et, en prenant un autre chemin,
  le générateur réussira à générer l'ensemble des salles.
  \item \textbf{Taille minimale d'entrée}: La génération de plateformes et 
  de pièges pourrait rendre l'entrée dans une salle impossible dans des cas
  où l'entrée d'une salle serait trop petite. Afin d'éviter cela,
  lorsqu'elles se placent le long d'un mur, les coordonnées aléatoires ont
  été restreintes afin que l'entrée vers la salle suivante aie toujours
  une taille minimale. Cette taille a été définie à 2 blocs. Dans la
  figure~\ref{fig:room_placement}, on peut voir que peu importe où se génère la
  salle, l'entrée de la salle verte vers la salle bleue aura toujours une
  taille d'au moins 2 blocs.
\end{itemize}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\textwidth]{images/room_placement.png}
  \caption{Un exemple de placement de salle.}
  Une salle est représentée en vert.\\ 
  Si la direction haut est choisie, une salle de taille 3x3 peut\\
  se générer n'importe où dans la zone bleue.
  \label{fig:room_placement}
\end{figure}

Les salles étant une donnée réutilisée fréquemment par le générateur,
elles sont stockées en tant que liste de vecteurs contenant une position
x et y, ainsi que la taille de la salle (voir figure~\ref{fig:room_data}).

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{images/room_storage.png}
  \caption{Une représentation du stockage d'une salle, 
  en tant que coordonnée et taille de salle}
  \label{fig:room_data}
\end{figure}

\subsubsection{Génération des murs}

\subsubsection{Génération du chemin}

\subsubsection{Fausses plateformes et échelles}

\subsubsection{Placement des blocs spéciaux}

\subsubsection{Placement des pièges}

\subsubsection{Placement de la sortie}

\subsection{Monde de test}

Afin de tester des fonctionnalités du jeu comme les collisions, les 
échelles ou autres, un monde de test a été ajouté, sous la forme d'un 
générateur de monde. Dans le code, nous pouvons changer le générateur de
niveau en notre générateur de monde de test, et le monde généré sera alors
un monde simple, contenant une plateforme et autres fonctionnalités que
nous voulons tester (voir figure~\ref{fig:test_world}).

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{images/test_world.png}
  \caption{Une capture d'écran du monde de test}
  \label{fig:test_world}
\end{figure}

\section{Le personnage}
\subsection{Les contrôles de base}
\subsection{Le saut}
\subsubsection{Le saut modulable}
%ça fait partie des choix qu'on a fait puis abandonné, c'est important à mentionner
\subsubsection{Le double saut}
\subsection{Le dash}
%Faudra aussi mentionner qu'on a eu du mal à trouver des contrôles convenables
\subsection{Le score et les vies}

\section{La physique}
\subsection{La gestion des collisions}
\subsubsection{Les propriétés des blocks}
\subsection{Calcul de la résistance de l'air}

\section{Notre organisation}
\subsection{La définition des tâches}
\subsubsection{La répartition du travail}
\subsection{Les outils utilisés}
% ça serait important de mentionner qu'on a mis un peu de temps à avoir un trello
% je pense aussi que l'ordre dans lequel on a mis les outils en place peut être interessant à rajouter
\subsubsection{GameDev Framework}
% Il faut quand même mentionner notre cher Jube pour son joli framework
\subsubsection{Discord}
\subsubsection{Google Docs} %Pour les idées à la base
\subsubsection{Trello}
\subsubsection{Git et Github}
\subsubsection{IDE}
% Cette section là elle est marrante parse que personne utilise le même
\newpage

\section{Conclusion}
% On a quand même une conclusion ici avant les autres points
\subsection{Points d'amélioration}
\subsubsection{Ce qu'on aurait voulu ajouter}
%c.f le gdoc
\subsubsection{Wave Function Collapse}
\subsubsection{Pathfinding amélioré}
\subsubsection{La physique} % ;-;


\end{document}
